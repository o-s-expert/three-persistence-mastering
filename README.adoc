= The three goals to achieve the Java persistence mastering
:toc: auto

== Business

* The reason that we're coding is the goal.

Software Engineer Definition by  https://www.amazon.com/dp/B0BLXCXT3R/[Modern Software Engineering's] book:

> Software Engineering is the application of an empirical, scientific approach to finding efficient, economic solutions to practical problems in software.

=== DDD

* Bringing the code close to the business.
* There are tactical and strategic perspectives

* *Strategic*: it's a business language: Bounded Context, ubiquitous language, context Maps.
* *Tactical*: implementation, classes, and modules.

==== Patterns

* Entities
* Value Object
* Services
* Repository
* Aggregator

==== Books

* https://www.amazon.com.br/dp/1098100131[Learning Domain-Driven Design: Aligning Software Architecture and Business Strategy]
* https://www.infoq.com/minibooks/domain-driven-design-quickly/[Domain Driven Design Quickly]

=== Understanding and converting to the code

There are several, such as story Storming, Story Mapping, and UML. My favorite one is Domain storytelling.

* https://www.amazon.com.br/dp/0137458916[Domain Storytelling: A Collaborative, Visual, and Agile Way to Build Domain-Driven Software]

The tool: https://egon.io/[Egon.io]

image::https://domainstorytelling.org/assets/images/home/metropolis-1-animated.gif[The tool example]

== Isolation

* We are keeping the code safe from technology.


Just enough software Architecture: A risk-driven Approach:

> To be successful at combating the scale and complexity of software in the next decade, developers will need improved weapons... in three categories: partitioning, knowledge, and *abstraction*.

> *Abstraction* can effectively combat complexity and scale because it shrinks problems, and smaller problems are easier to reason about it.

=== Abstraction

=== Layers, Layers, Layers

=== When Layer can become an enemy

== Performance

=== Take advantage of the database

=== Models

== Conclusion
